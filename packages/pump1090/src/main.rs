#[macro_use]
extern crate clap;
extern crate serde_json;

use dotenv::dotenv;

use std::error::Error;
use std::fs::File;
use std::io::{self, Read, Write};
use std::net::TcpStream;
use std::{env, thread, time};

use url::Url;

use clap::{App};

use serde_json::Value;

use tungstenite::protocol::WebSocket;
use tungstenite::stream::Stream as StreamSwitcher;
use tungstenite::{connect, Message};

type AutoStream = StreamSwitcher<TcpStream, TlsStream<TcpStream>>;

#[cfg(feature = "tls")]
use native_tls::TlsStream;

/// Parses arguments and kicks of the WebSocket initialization
fn main() -> () {
    // load env file
    dotenv().ok();
    // load cli args
    let yaml = load_yaml!("cli.yaml");
    let matches = App::from_yaml(yaml).get_matches();

    let undefined: &str = "undefined";
    let device_id: String = unwrap_arg(
        "DEVICE_ID",
        matches.value_of("device-id"),
        undefined);
    let serve1090_secret: String = unwrap_arg(
        "SERVE1090_SECRET",
        matches.value_of("serve1090-secret"),
        undefined);
    let filename: String = unwrap_arg(
        "DUMPFILE_PATH",
        matches.value_of("dumpfile"),
        "data/aircraft.json");
    let endpoint: String = unwrap_arg(
        "WS_ENDPOINT",
        matches.value_of("endpoint"),
        "ws://localhost:3000/pump");

    if serve1090_secret == undefined {
        handle_fatal(String::from("unable to find serve1090_secret").into());
    }

    println!("Initializing pump1090...");
    println!("Device id: {}", device_id);
    println!("Dumpfile path: {}", filename);
    println!("Websocket endpoint: {}", endpoint);
    init_pump(&device_id, &serve1090_secret, &filename, &endpoint);
    println!("pump1090 terminated.")
}

/// Computes the value of an arg; does this by checking if the arg was specified on the command
/// line, then checking .env for the value of env_var_name, and finally using default_val
///
/// # Arguments
///
/// * `env_var_name` - .env key of the arg
/// * `cli_arg` - value of cli arg generated by clap
/// * `default_val` - default value of the arg if there is no .env or cli value
fn unwrap_arg(env_var_name: &str, cli_arg: Option<&str>, default_val: &str) -> String {
    let env_arg = env::var(env_var_name).unwrap_or_else(|_| default_val.to_string());
    let unwrapped_arg = cli_arg.unwrap_or_else(|| &env_arg);
    unwrapped_arg.to_string()
}

/// Starts an infinite loop that establishes the WebSocket connection and starts the timer that
/// will watch the dumpfile; loops infinitely so that, if the WebSocket connection is broken,
/// it will attempt to re-establish the connection (recursion not used to avoid stack overflow)
///
/// # Arguments
///
/// * `device_id` - unique string identifier of the machine from args
/// * `serve1090_secret` - serve1090 uuid that the receiving server expects
/// * `filename` - path to the dumpfile JSON
/// * `endpoint` - WebSocket endpoint of the server
fn init_pump(
    device_id: &str,
    serve1090_secret: &str,
    filename: &str,
    endpoint: &str,
) -> () {
    loop {
        let socket = init_pipe(endpoint);
        init_dump_timer(device_id, serve1090_secret, filename, socket).unwrap_or_else(handle_fatal);
    }
}

/// Creates the WebSocket connection, repeatedly attempting to connect to the endpoint every
/// 5 seconds until connection occurs; returns socket
///
/// # Arguments
///
/// * `endpoint` - WebSocket endpoint with which to establish connection
fn init_pipe(endpoint: &str) -> WebSocket<AutoStream> {
    let mut attempt: isize = 1;
    let sleep_interval: u64 = 5000;
    loop {
        print!(
            "\rAttempting to establish pipe with {} (attempt {})",
            endpoint, attempt
        );
        io::stdout().flush().unwrap();
        let resp = connect(Url::parse(endpoint).unwrap());
        match resp {
            Ok((socket, _)) => {
                println!("\nSuccess (on attempt {})", attempt);
                break socket;
            }
            Err(_) => {
                attempt += 1;
                thread::sleep(time::Duration::from_millis(sleep_interval));
            }
        }
    }
}

/// Reads the dumpfile JSON every read_interval seconds and send it to the WebSocket
/// endpoint
///
/// # Arguments
///
/// * `device_id` - unique string identifier of the machine from args
/// * `serve1090_secret` - serve1090 uuid that the receiving server expects
/// * `filename` - path to the dumpfile JSON
/// * `socket` - WebSocket created by `init_pipe`
fn init_dump_timer(
    device_id: &str,
    serve1090_secret: &str,
    filename: &str,
    mut socket: WebSocket<AutoStream>,
) -> Result<(), Box<dyn Error>> {
    let mut run_count: isize = 1;
    let read_interval: u64 = 1000;
    print!("Pump count: {}", run_count);
    io::stdout().flush().unwrap();
    loop {
        let data = read_json(device_id, serve1090_secret, filename)?;
        match pump_data(data, socket) {
            Ok(s) => socket = s, // data send was successful
            Err(_) => {
                println!("\nUnable to write to pipe; attempting to re-establish connection...");
                break Ok(());
            }
        }
        run_count = run_count + 1;
        print!("\rPump count: {}", run_count);
        io::stdout().flush().unwrap();
        thread::sleep(time::Duration::from_millis(read_interval));
    }
}

/// Opens and reads the input file, parses it into JSON and attached metadata,
/// and then stringifies and returns it
///
/// # Arguments
///
/// * `device_id` - unique string identifier of the machine from args
/// * `serve1090_secret` - serve1090 uuid that the receiving server expects
/// * `filename` - path to the dumpfile JSON
fn read_json(
    device_id: &str,
    serve1090_secret: &str,
    filename: &str,
) -> Result<String, Box<dyn Error>> {
    // first, read the input file to string
    let mut file = File::open(filename)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    // then, serialize it
    let mut data: Value = serde_json::from_str(&contents)?;
    // attach metadata
    data["device_id"] = device_id.into();
    data["token"] = serve1090_secret.into();
    let payload: String = serde_json::to_string(&data)?;
    Ok(payload)
}

/// Takes a message (string) and sends it to a specified WebSocket
///
/// # Arguments
///
/// * `data` - message to send through WebSocket, must be a string
/// * `socket` - WebSocket created by `init_pipe`
fn pump_data(
    data: String,
    mut socket: WebSocket<AutoStream>,
) -> Result<WebSocket<AutoStream>, tungstenite::error::Error> {
    // ping the socket for liveness check
    socket.write_message(Message::Ping(Vec::new()))?;
    // attempt the actual write
    socket.write_message(Message::Text(data))?;
    Ok(socket)
}

/// Handles a fatal error and panics the thread
///
/// # Arguments
/// * `e` - Error object
fn handle_fatal(e: Box<dyn Error>) -> () {
    println!("FATAL ERROR ----------------------------------------------------------");
    println!("Detail: {}", e);
    panic!()
}
