const _ = require('lodash');
const logger = require('../lib/logger')().scope('aircraft store');
const { AIRCRAFT_SCHEMA } = require('./schemas');
const {
  secondsToMillis,
  millisToSeconds
} = require('../lib/utils');
const RedisService = require('../services/redis-service');
const redis = new RedisService();

// maximum age of new data that will be accepted into the store
const MAX_DATA_AGE = 10000;

module.exports = {
  addAircraft,
  getAllAircraft,
  getValidAircraft,
  getInvalidAircraft,
  getValidatedAircraftAt,
  getNumValidAircraft
};

/**
 * Accept new dump1090 aircraft data to merge into the store
 *
 * @param data - raw JSON object generated by dump109 with data.now in seconds since epoch
 * @returns {boolean} true if the data was accepted, false if it was rejected
 */
async function addAircraft (data) {
  const clientNowMillis = secondsToMillis(data.now);
  const now = Date.now();
  const age = now - clientNowMillis;
  if (age > MAX_DATA_AGE) {
    logger.warn('reject stale dump data', {
      clientTimestamp: new Date(clientNowMillis).toISOString(),
      age: millisToSeconds(age).toFixed(2)
    });
  }
  // first, update and filter the data to generate a hash
  const newAircraft = createAircraftStore(data.aircraft.map(setUpdated));
  await validateAndWrite(newAircraft);
  logger.info('accept dump data', {
    messages: data.messages,
    clientTimestamp: new Date(clientNowMillis).toISOString()
  });
}

/**
 * Convert an array of aircraft hashes into a hash mapping hex to its
 * respective aircraft hash
 *
 * @param aircraftArray array of aircraft from dump1090
 * @returns hash of hexes mapped to respective aircraft objects
 */
function createAircraftStore (aircraftArray = []) {
  return aircraftArray.reduce((acc, aircraft) => {
    acc[aircraft.hex] = aircraft;
    return acc;
  }, {});
}

/**
 * Validate an aircraft store and write it to Redis
 *
 * @param store - aircraft store validate and filter
 */
async function validateAndWrite (store) {
  const pipeline = redis.pipeline();
  Object.entries(store).forEach(([hex, aircraft]) => {
    const { value: validatedBody, error } = AIRCRAFT_SCHEMA.validate(aircraft);
    if (!error) {
      validatedBody.error = false;
      pipeline.hsetJsonEx('store:valid', hex, validatedBody, 10);
    } else {
      aircraft.error = error.message.replace(/"/g, '\'');
      pipeline.hsetJsonEx('store:invalid', hex, aircraft, 60);
    }
    redis.hsetJsonEx('store:all', hex, aircraft, 60);
  });
  await pipeline.exec();
}

/**
 * Get entire store of all aircraft
 */
function getAllAircraft () {
  return getStore('store:all');
}

/**
 * Get store of valid aircraft
 */
function getValidAircraft () {
  return getStore('store:valid');
}

/**
 * Get store of invalid aircraft
 */
function getInvalidAircraft () {
  return getStore('store:invalid');
}

/**
 * Get a specific aircraft
 *
 * @param {string} hex - hex of the aircraft to get
 */
function getAircraftAt (hex) {
  return redis.hgetJson('store:all', hex);
}

/**
 * Get a specific aircraft that has been validated
 *
 * @param {string} hex - hex of the aircraft to get
 */
function getValidatedAircraftAt (hex) {
  return redis.hgetJson('store:valid', hex);
}

function getNumValidAircraft () {
  return redis.hlen('store:valid');
}

async function getStore (store) {
  const aircraft = await redis.hgetAllAsJsonValues(store);
  return {
    now: Date.now(),
    count: aircraft.length,
    aircraft
  };
}

function setUpdated (aircraft) {
  aircraft.updated = Date.now();
  return aircraft;
}
