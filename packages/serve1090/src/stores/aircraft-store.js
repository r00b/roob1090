const logger = require('../lib/logger')().scope('aircraft store');
const { AIRCRAFT_SCHEMA } = require('./schemas');
const {
  secondsToMillis,
  millisToSeconds
} = require('../lib/utils');

const RedisService = require('../services/redis-service');
const redis = new RedisService();
const {
  ALL_AIRCRAFT_STORE,
  VALID_AIRCRAFT_STORE,
  INVALID_AIRCRAFT_STORE
} = require('../lib/redis-keys');

// maximum age of new data that will be accepted into the store
const MAX_DATA_AGE = 10000;

/**
 * Accept new dump1090 aircraft data to merge into the store
 *
 * @param data - raw JSON object generated by dump109 with data.now in seconds since epoch
 * @returns {boolean} true if the data was accepted, false if it was rejected
 */
async function addAircraft (data) {
  const clientNowMillis = secondsToMillis(data.now);
  const now = Date.now();
  const age = now - clientNowMillis;
  if (age > MAX_DATA_AGE) {
    logger.warn('reject stale dump data', {
      clientTimestamp: new Date(clientNowMillis).toISOString(),
      age: millisToSeconds(age).toFixed(2)
    });
  }
  // first, update and filter the data to generate a hash
  const newAircraft = createAircraftStore(data.aircraft.map(setUpdated));
  await validateAndWrite(newAircraft);
  logger.info('accept dump data', {
    messages: data.messages,
    clientTimestamp: new Date(clientNowMillis).toISOString()
  });
}

/**
 * Convert an array of aircraft hashes into a hash mapping hex to its
 * respective aircraft hash
 *
 * @param aircraftArray array of aircraft from dump1090
 * @returns hash of hexes mapped to respective aircraft objects
 */
function createAircraftStore (aircraftArray = []) {
  return aircraftArray.reduce((acc, aircraft) => {
    acc[aircraft.hex] = aircraft;
    return acc;
  }, {});
}

/**
 * Validate an aircraft store and write it to Redis
 *
 * @param store - aircraft store validate and filter
 */
async function validateAndWrite (store) {
  const pipeline = redis.pipeline();
  Object.entries(store).forEach(([hex, aircraft]) => {
    const { value: validatedBody, error } = AIRCRAFT_SCHEMA.validate(aircraft);
    if (!error) {
      validatedBody.error = false;
      pipeline.hsetJsonEx(VALID_AIRCRAFT_STORE, hex, validatedBody, 10);
    } else {
      aircraft.error = error.message.replace(/"/g, '\'');
      pipeline.hsetJsonEx(INVALID_AIRCRAFT_STORE, hex, aircraft, 60);
    }
    redis.hsetJsonEx(ALL_AIRCRAFT_STORE, hex, aircraft, 60);
  });
  await pipeline.exec();
}

function getAllAircraft () {
  return getStore(ALL_AIRCRAFT_STORE);
}

function getValidAircraft () {
  return getStore(VALID_AIRCRAFT_STORE);
}

function getInvalidAircraft () {
  return getStore(INVALID_AIRCRAFT_STORE);
}

function getAircraftWithHex (hex) {
  return redis.hgetAsJson(ALL_AIRCRAFT_STORE, hex);
}

function getValidAircraftWithHex (hex) {
  return redis.hgetAsJson(VALID_AIRCRAFT_STORE, hex);
}

function getTotalAircraftCount () {
  return redis.hlen(ALL_AIRCRAFT_STORE);
}

function getValidAircraftCount () {
  return redis.hlen(VALID_AIRCRAFT_STORE);
}

async function getStore (store) {
  const aircraft = await redis.hgetAllAsJsonValues(store);
  return {
    now: Date.now(),
    count: aircraft.length,
    aircraft
  };
}

function setUpdated (aircraft) {
  aircraft.updated = Date.now();
  return aircraft;
}

module.exports = {
  addAircraft,
  getAllAircraft,
  getValidAircraft,
  getInvalidAircraft,
  getAircraftWithHex,
  getValidAircraftWithHex,
  getTotalAircraftCount,
  getValidAircraftCount
};
