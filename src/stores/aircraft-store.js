const _ = require('lodash');
const logger = require('./../../lib/logger');
const AIRCRAFT_SCHEMA = require('./../schemas/aircraft');
const { rightPad } = require('./../utils');
const MAX_DATA_AGE = 60000;

module.exports = {
  init,
  setNewData,
  getRawAircraft,
  getCurrentAircraft,
  getExcludedAircraft,
  shutdown
};

// INIT

function init () {
  if (!this.initialized) {
    // set up data maps
    this.currentRawAircraft = _createStore('raw');
    this.currentValidAircraft = _createStore('valid');
    // init jobs
    this.jobs = [
      setInterval(() => this.currentValidAircraft = _purgeAircraft(this.currentValidAircraft, 10000), 1000),
      setInterval(() => this.currentRawAircraft = _purgeAircraft(this.currentRawAircraft, 60000), 10000),
      setInterval(() => _emptyPurgeList(this.currentRawAircraft, this.currentValidAircraft), 1800000)
    ];
  } else throw new Error('store already initialized');
  this.initialized = true;
  logger.store({
    message: _fmtMsg('initialize store')
  });
}

// JOBS

/**
 * Purge aircraft out of the store that are stale
 *
 * @param store the serve1090 aircraft store to purge
 * @param maxAge maximum allowed age of the aircraft (where age begins when serve1090
 *        receives the aircraft or an update to it)
 * @returns new serve1090 aircraft store without stale aircraft
 * @private
 */
function _purgeAircraft (store, maxAge) {
  const result = _.cloneDeep(store);
  result.aircraft = _.pickBy(store.aircraft, function (aircraft) {
    const age = Date.now() - aircraft.updated;
    const tooOld = age > maxAge;
    if (tooOld) {
      result.purged.add(aircraft.hex);
      logger.store({
        message: _fmtMsg('purge aircraft'),
        store: store.name,
        numAircraft: store.aircraft.length,
        hex: aircraft.hex,
        age,
        max: maxAge,
        numPurged: result.purged.size
      });
    }
    return !tooOld;
  });
  return result;
}

/**
 * Empty the purge list, since the same aircraft will be seen over time
 * @param store the store containing the purge list to clear
 * @private
 */
function _emptyPurgeList (...store) {
  store.forEach(s => {
    if (s.purged.size) {
      s.purged.clear();
      logger.store({
        message: _fmtMsg('empty purge list'),
        store: s.name
      });
    }
  });
}

// SHUTDOWN

function shutdown () {
  this.jobs.map(clearInterval);
  logger.store({
    message: _fmtMsg('shutdown store')
  });
}

// CREATE

/**
 * Accept new dump1090 aircraft data to merge into the store
 *
 * @param data raw JSON object generated by dump109 with data.now in seconds since epoch
 * @returns {boolean} true if the data was accepted, false if it was rejected
 */
function setNewData (data) {
  _checkIfInitialized(this.initialized);
  const nowMillis = _convertSecondsToMillis(data.now);
  const age = Date.now() - nowMillis;
  if (age > MAX_DATA_AGE) {
    return false;
  }
  logger.store({
    message: _fmtMsg('receive dump1090 data'),
    messages: data.messages,
    clientTimestamp: new Date(nowMillis).toISOString()
  });
  // first, update and filter the data
  const newAircraftMap = _mapifyAircraftArray(data.aircraft.map(_setUpdated));
  const { validatedMap, errors } = _validateAircraftMap(newAircraftMap);
  // set errors onto newAircraftMap so they can be returned with excluded
  Object.entries(errors).forEach(([hex, error]) => {
    newAircraftMap[hex].error = error;
  });
  // then merge it with existing data stores
  this.currentRawAircraft = _mergeIntoStore(this.currentRawAircraft, newAircraftMap);
  this.currentValidAircraft = _mergeIntoStore(this.currentValidAircraft, validatedMap);
  return true;
}

/**
 * Merge a mapified dump1090 JSON object into an existing serve1090 aircraft
 * data store
 *
 * @param store existing serve1090 store of aircraft
 * @param newMap unmerged serve1090 map of aircraft | { hex: aircraft }
 * @returns newly merged aircraft data store | { hex: aircraft }
 * @private
 */
function _mergeIntoStore (store, newMap) {
  const updated = [];
  const added = [];
  const mergedStore = Object.entries(newMap).reduce((acc, [hex, aircraft]) => {
    let logArray;
    if (store.aircraft[hex]) {
      logArray = updated;
    } else {
      logArray = added;
      if (store.purged.has(hex)) {
        store.purged.delete(hex);
        logger.store({
          message: _fmtMsg('add purged aircraft'),
          hex,
          seen: aircraft.seen
        });
      }
    }
    logArray.push(hex);
    acc.aircraft[hex] = aircraft;
    return acc;
  }, _.cloneDeep(store));
  // log results
  const size = Object.keys(mergedStore.aircraft).length;
  logger.store({
    message: _fmtMsg('add new aircraft'),
    store: store.name,
    num: added.length,
    size
  });
  logger.store({
    message: _fmtMsg('update existing aircraft'),
    store: store.name,
    num: updated.length,
    size
  });
  return mergedStore;
}

/**
 * Filter an aircraft serve1090 data store; validate against AIRCRAFT_SCHEMA
 * and return the validated map
 *
 * @param map serve1090 aircraft map to validate and filter
 * @returns validated and filtered serve1090 aircraft map
 * @private
 */
function _validateAircraftMap (map) {
  const errors = {};
  const validatedMap = Object.entries(map).reduce((acc, [hex, aircraft]) => {
    const { value: validatedBody, error } = AIRCRAFT_SCHEMA.validate(aircraft);
    if (!error) {
      acc[hex] = validatedBody;
    } else {
      errors[hex] = error.message.replace(/"/g, '\'');
    }
    return acc;
  }, {});
  return {
    validatedMap,
    errors
  }
}

// RETRIEVE

function getRawAircraft () {
  _checkIfInitialized(this.initialized);
  return _exportStore(this.currentRawAircraft);
}

function getCurrentAircraft () {
  _checkIfInitialized(this.initialized);
  return _exportStore(this.currentValidAircraft);
}

function getExcludedAircraft () {
  _checkIfInitialized(this.initialized);
  const currentAircraft = this.currentValidAircraft;
  const excluded = _.pickBy(this.currentRawAircraft, a => !currentAircraft[a.hex]);
  return _exportStore(excluded);
}

function _exportStore (store) {
  try {
    const aircraft = Object.values(store.aircraft) || [];
    return {
      now: Date.now(),
      numAircraft: aircraft.length,
      aircraft
    };
  } catch (e) {
    return {
      now: Date.now(),
      error: e.message
    };
  }
}

// HELPERS

function _createStore (name) {
  return {
    name,
    aircraft: {},
    purged: new Set()
  };
}

function _convertSecondsToMillis (seconds) {
  return seconds * 1000;
}

function _setUpdated (aircraft) {
  aircraft.updated = Date.now();
  return aircraft;
}

function _mapifyAircraftArray (aircraftArray = []) {
  return aircraftArray.reduce((acc, aircraft) => {
    acc[aircraft.hex] = aircraft;
    return acc;
  }, {});
}

function _fmtMsg (msg) {
  return rightPad(msg, 25);
}

function _checkIfInitialized (initialized) {
  if (!initialized) throw new Error('store not initialized');
}

function _printAircraft (aircraft) {
  const {
    flight,
    hex,
    seen,
    updated,
    alt_baro,
    true_heading,
    track,
    lat,
    lon
  } = aircraft;
  console.log('-------------------------------');
  console.log(`Flight: ${flight}`);
  console.log(`Hex: ${hex}`);
  console.log(`Seen: ${seen}`);
  console.log(`Updated: ${updated}`);
  console.log(`Altitude: ${alt_baro}`);
  console.log(`True heading: ${true_heading}`);
  console.log(`Track: ${track}`);
  console.log(`Lat: ${lat}`);
  console.log(`Long: ${lon}`);
  console.log('-------------------------------');
}

// function _compute (aircraft, airspace, excludedAircraft) {
//
//   aircraft.forEach(a => {
//     if (a.flight.trim() === 'AAL1310') _logAircraft(a);
//   });
//
//   const aircraftInAirspace = _computeAircraftInAirspace(aircraft, airspace);
//   const validAircraft = aircraftInAirspace.filter(aircraft => {
//
//     // const heading = aircraft.track ? aircraft.track : aircraft.true_heading;
//     // const goodHeading = heading >= airspace.minHeading && heading <= airspace.maxHeading; // TODO heading violates as soon as leaves runway
//     const altitude = aircraft.alt_baro;
//     const goodAltitude = altitude <= airspace.maxAltitude;
//
//     // const excludeAircraft = turf.booleanPointInPolygon(turf.point([aircraft.lon, aircraft.lat]), turf.polygon(excludedAircraft.coordinates));
//
//     return goodAltitude;
//   });
//   console.log('\n--------------------');
//   console.log(airspace.name);
//   validAircraft.map(a => console.log(a.flight));
//   return validAircraft.map(a => a.flight);
// }
//
// function _computeAircraftInAirspace (aircraft, airspace) {
//   return aircraft.filter(aircraft => {
//     const aircraftCoordinates = [aircraft.lon, aircraft.lat];
//     return turf.booleanPointInPolygon(turf.point(aircraftCoordinates), turf.polygon(airspace.coordinates));
//   });
// }
//
// function getCompute () {
//   const landing = _compute(Object.values(this.currentValidAircraft), dca.approach());
//   const takeoff = _compute(Object.values(this.currentValidAircraft), dca.departure());
//   return {
//     landing,
//     takeoff
//   }
// }
